---
title: "g13_milestone_3"
author: "Henry Burke, Beomseong Kim, Jack Vaughn, John Derr, Sanjay Nagarimadugu"
output: rmdformats::downcute
---

# Full Interface
- All original code below

``` {r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

```


---

## Sanjay Original Code

```{r}
# Load required libraries
library(tidyverse)
library(leaflet)
library(rnaturalearth)
library(sf)
library(scales)
library(htmltools)
library(htmlwidgets)

# Read and prepare data
alz <- read_csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv") |>
  mutate(
    across(Country, str_replace, "USA", "United States"),
    across(Country, str_replace, "UK", "United Kingdom")
  ) |>
  rename_at(vars(25), ~ "Alzheimer's Diagnosis") |>
  mutate(`Alzheimer's Diagnosis` = if_else(`Alzheimer's Diagnosis` == "Yes", 1, 0))

# Get country shapes
countries_geo <- ne_countries(scale = "medium", returnclass = "sf")
countries_geo$Country <- countries_geo$name
countries_geo$Country[countries_geo$Country == "United States of America"] <- "United States"

# Compute metrics
country_metrics <- alz |>
  group_by(Country) |>
  summarize(
    sample_size = n(),
    alzheimers_rate = mean(`Alzheimer's Diagnosis`, na.rm = TRUE),
    diabetes_rate = mean(Diabetes == "Yes", na.rm = TRUE),
    avg_age = mean(Age, na.rm = TRUE)
  ) |>
  filter(sample_size >= 5, !is.na(diabetes_rate), !is.na(avg_age))

# Get centroids and coordinates
suppressWarnings({
  countries_centroid <- st_centroid(countries_geo)
})
countries_coords <- as.data.frame(st_coordinates(countries_centroid))
countries_coords$Country <- countries_geo$Country

circles_data <- country_metrics |>
  inner_join(countries_coords, by = "Country")

map_data <- countries_geo |>
  inner_join(country_metrics, by = "Country")

# Define palettes
diabetes_palette <- colorNumeric("YlOrBr", domain = country_metrics$diabetes_rate)
age_palette <- colorNumeric("YlOrBr", domain = country_metrics$avg_age)

alz_radius <- function(rate) sqrt(rate) * 12
alz_color <- "darkorchid"

# Alzheimer’s custom circle size legend
addAlzheimersLegend <- function(map) {
  addLegendCustom <- function(map, colors, labels, sizes, opacity = 1) {
    legendHTML <- paste0(
      "<div style='line-height: 1.3em; font-size: 11px;'>",
      paste(
        "<div style='display: flex; align-items: center;'>",
        "<svg width='", sizes * 2, "' height='", sizes * 2, "'>",
        "<circle cx='", sizes, "' cy='", sizes, "' r='", sizes, "' fill='", colors, "' fill-opacity='", opacity, "' stroke='black' stroke-width='1'/>",
        "</svg>",
        "<span style='margin-left: 6px;'>", labels, "</span>",
        "</div>", collapse = ""),
      "</div>"
    )
    addControl(map, html = legendHTML, position = "bottomleft")
  }

  sizes <- c(4, 8, 12)
  labels <- c("Low Alzheimer's Rate", "Medium", "High")
  colors <- rep(alz_color, 3)

  map <- addLegendCustom(map, colors, labels, sizes, opacity = 0.8)
  return(map)
}

# Instructions box
instructions_html <- HTML("<div style='padding: 4px 6px; background: white; font-size: 11px; border: 1px solid gray; border-radius: 4px;'>
<b>How to use:</b><br>
Hover for details<br>
Switch layers top-right<br>
Circle = Alzheimer's rate
</div>")

# Custom legends (as hidden divs)
diabetes_legend <- HTML("
  <div id='diabetes-legend' style='display: none; background: white; padding: 6px; font-size: 12px; border: 1px solid #999; border-radius: 4px;'>
    <strong>Diabetes Rate</strong><br>
    <svg height='80' width='20'>
      <defs>
        <linearGradient id='grad1' x1='0%' y1='100%' x2='0%' y2='0%'>
          <stop offset='0%' style='stop-color:#ffffcc;stop-opacity:1' />
          <stop offset='100%' style='stop-color:#d95f0e;stop-opacity:1' />
        </linearGradient>
      </defs>
      <rect width='20' height='80' fill='url(#grad1)' />
    </svg><br>
    <small>Low → High</small>
  </div>
")

age_legend <- HTML("
  <div id='age-legend' style='display: none; background: white; padding: 6px; font-size: 12px; border: 1px solid #999; border-radius: 4px;'>
    <strong>Average Age</strong><br>
    <svg height='80' width='20'>
      <defs>
        <linearGradient id='grad2' x1='0%' y1='100%' x2='0%' y2='0%'>
          <stop offset='0%' style='stop-color:#ffffcc;stop-opacity:1' />
          <stop offset='100%' style='stop-color:#d95f0e;stop-opacity:1' />
        </linearGradient>
      </defs>
      <rect width='20' height='80' fill='url(#grad2)' />
    </svg><br>
    <small>Low → High</small>
  </div>
")

# Build map
combined_map <- leaflet() |>
  addTiles() |>
  setView(lng = 0, lat = 20, zoom = 2) |>

  # Diabetes layer
  addPolygons(
    data = map_data,
    fillColor = ~diabetes_palette(diabetes_rate),
    fillOpacity = 0.7,
    weight = 1, color = "#333333",
    highlightOptions = highlightOptions(weight = 2, color = "#666666"),
    label = ~paste0(Country, ": Diabetes Rate = ", percent(diabetes_rate)),
    popup = ~paste0(
      "<strong>", Country, "</strong><br>",
      "Diabetes Rate: ", percent(diabetes_rate), "<br>",
      "Average Age: ", round(avg_age, 1), " years<br>",
      "Alzheimer's Rate: ", percent(alzheimers_rate), "<br>",
      "Sample Size: ", sample_size
    ),
    group = "Diabetes Rate"
  ) |>

  # Age layer
  addPolygons(
    data = map_data,
    fillColor = ~age_palette(avg_age),
    fillOpacity = 0.7,
    weight = 1, color = "#333333",
    highlightOptions = highlightOptions(weight = 2, color = "#666666"),
    label = ~paste0(Country, ": Average Age = ", round(avg_age, 1), " years"),
    popup = ~paste0(
      "<strong>", Country, "</strong><br>",
      "Average Age: ", round(avg_age, 1), " years<br>",
      "Diabetes Rate: ", percent(diabetes_rate), "<br>",
      "Alzheimer's Rate: ", percent(alzheimers_rate), "<br>",
      "Sample Size: ", sample_size
    ),
    group = "Average Age"
  ) |>

  # Alzheimer’s circles
  addCircleMarkers(
    data = circles_data,
    lng = ~X, lat = ~Y,
    radius = ~alz_radius(alzheimers_rate),
    stroke = TRUE, color = "black", weight = 1,
    fillColor = alz_color, fillOpacity = 0.8,
    popup = ~paste0(
      "<strong>", Country, "</strong><br>",
      "Alzheimer's Rate: ", percent(alzheimers_rate)
    ),
    group = c("Diabetes Rate", "Average Age")
  ) |>

  # Layer toggles
  addLayersControl(
    baseGroups = c("Diabetes Rate", "Average Age"),
    options = layersControlOptions(collapsed = FALSE)
  ) |>

  # Add static controls
  addAlzheimersLegend() |>
  addControl(instructions_html, position = "topleft") |>
  addControl(diabetes_legend, position = "bottomright") |>
  addControl(age_legend, position = "bottomright") |>

  # JavaScript toggle logic
  onRender("
    function(el, x) {
      var diabetesLegend = document.getElementById('diabetes-legend');
      var ageLegend = document.getElementById('age-legend');

      var radios = el.querySelectorAll('input[type=radio]');
      radios.forEach(function(radio) {
        radio.addEventListener('change', function() {
          if (radio.value.includes('Diabetes')) {
            diabetesLegend.style.display = 'block';
            ageLegend.style.display = 'none';
          } else {
            diabetesLegend.style.display = 'none';
            ageLegend.style.display = 'block';
          }
        });
      });

      diabetesLegend.style.display = 'block';  // show one by default
    }
  ")

# Show map
combined_map

```

---

## Henry Original Code

``` {r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(shiny)
library(leaflet)
library(rnaturalearth)
library(sf)

alz = read_csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv") |>
  mutate(
    across(Country, str_replace, "USA", "United States"),
    across(Country, str_replace, "UK", "United Kingdom")) |>
  rename_at(vars(25), ~ "Alzheimer's Diagnosis")
  

happy = read_csv("https://uwmadison.box.com/shared/static/z79r9iafg3tzvm6cxagvft9auvcu868t.csv") |>
  rename(Country = `Country name`)

lat_long = read_csv("https://uwmadison.box.com/shared/static/b9a1uvwrho690zvwc2wfzrwlwx0jtehp.csv") |>
  select(id, name, latitude, longitude) |>
  rename(Country = name)

temp = left_join(alz, happy, by="Country")

df = left_join(temp, lat_long, by="Country")
```

```{r}
# for addPolygons
df_countries = df |>
  filter(`Alzheimer's Diagnosis` == "Yes") |>
  group_by(Country, `Ladder score`) |>
  summarize(yes_count = n())
  
# for addCircles
df_points = df |>
  group_by(Country, latitude, longitude) |>
  summarize(tot_count = n()) |>
  left_join(df_countries, by="Country")

countries = as.data.frame(ne_countries(scale = "medium", returnclass = "sf")) |>
  rename(Country = name) |>
  mutate(across(Country, str_replace, "United States of America", "United States"))

df_countries_with_polygons = st_as_sf(
  full_join(df_countries, countries, by="Country") |>
  filter(!is.na(count))
  )

palette = colorNumeric(palette = "Blues", domain = df_countries_with_polygons$Count)

leaflet() |>
  addTiles() |>
  addPolygons(
    data = df_countries_with_polygons,
    fillColor = ~palette(`Ladder score`),
    fillOpacity = 0.7,
    color = "black",
    weight = 1 # ,
    # popup = ~paste(Country, ": ", `Ladder score`, " happiness index")
  ) |>
  addCircles(
    data = df_points,
    lng = ~longitude,
    lat = ~latitude,
    radius = ~sqrt(yes_count) * 5000,
    color = "red",
    fillOpacity = 0.5,
    popup = ~paste(Country, ": ", yes_count, " positive diagnoses of ", tot_count, " total people", "<br>",
                   "Ratio: ", round(yes_count/tot_count, digits=2))
  ) |>
  addLegend(
    pal = palette,
    values = df_countries_with_polygons$`Ladder score`,
    title = "World Happiness Index",
    position = "bottomright"
  ) |>
  setView(lng = 0, lat = 0, zoom = 2)
```

## Henry Revised Code

```{r, warning=FALSE, message=FALSE}
# loading & cleaning data

knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(shiny)
library(plotly)

alz = read_csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv") |>
  mutate(
    across(Country, str_replace, "USA", "United States"),
    across(Country, str_replace, "UK", "United Kingdom")) |>
  rename_at(vars(25), ~ "Alzheimer's Diagnosis")
  

happy = read_csv("https://uwmadison.box.com/shared/static/z79r9iafg3tzvm6cxagvft9auvcu868t.csv") |>
  rename(Country = `Country name`)

alz_by_country = left_join(alz, happy, by="Country") |>
  filter(`Alzheimer's Diagnosis` == "Yes") |>
  group_by(Country, `Ladder score`) |>
  summarize(yes_count = n())
```

```{r}
# static scatter plot

ggplot(alz_by_country) +
  geom_point(
    aes(x=`Ladder score`, y=yes_count), 
    size = 2
    ) +
  labs(
    title="World Happiness Index vs. Alzheimer's Diagnoses By Country",
    x="World Happiness Index Score",
    y="Number of Alzheimer's Diagnoses"
  )
```

```{r}
# dynamic scatter plot

ui <- fluidPage(
  plotlyOutput("plt", height = "600px")
)

server <- function(input, output, session) {
  p <- ggplot(alz_by_country,
              aes(x = `Ladder score`, y = yes_count,
                  text = paste0("Country: ", Country,
                                "<br>World Happiness Index: ", `Ladder score`,
                                "<br>Number of Alzheimer's Diagnoses: ", yes_count))) +
       geom_point(size = 2)
  
  output$plt <- renderPlotly({
    ggplotly(p, tooltip = "text") %>%
      layout(title = "World Happiness vs. Alzheimer's Diagnoses",
             xaxis = list(title = "World Happiness Index Score"),
             yaxis = list(title = "Number of Alzheimer's Diagnoses"))
  })
}

shinyApp(ui, server)
```




---

## John Original Code

```{r}
# Load required libraries
library(shiny)
library(tidyverse)
library(DT)
library(plotly)
library(shinyjs) # Added for toggleState



# It's generally better practice to define helper functions outside the server function
# if they don't rely on reactive values, or inside if they do but used in one place.
# Placing it here for clarity.
create_bins <- function(var, var_name, n_bins, show_other_opt) {
  if(is.numeric(var)) {
    # Create bins for numeric variables
    breaks <- quantile(var, probs = seq(0, 1, length.out = n_bins + 1), na.rm = TRUE)
    breaks <- unique(breaks) # Ensure unique breaks
    if(length(breaks) <= 1) { # Handle cases with a single unique value or all NAs
        # If only one break, maybe return the single value as a factor? Or a constant label.
        # Returning a constant label might be safer for grouping.
         return(factor(rep(paste0("Value: ", format(unique(na.omit(var))[1], digits=3)), length(var))))
    }
     # Adjust breaks if only two unique values resulted (min and max) to avoid single bin
    if(length(breaks) == 2 && length(unique(na.omit(var))) > 1) {
        breaks <- seq(min(var, na.rm=TRUE), max(var, na.rm=TRUE), length.out = n_bins + 1)
        breaks <- unique(breaks) # Ensure uniqueness again
         if(length(breaks) <= 1) { # Still problematic, fall back
             return(factor(rep(paste0("Value: ", format(unique(na.omit(var))[1], digits=3)), length(var))))
         }
    }
    return(cut(var, breaks = breaks, include.lowest = TRUE, dig.lab = 3))
  } else {
    # For categorical variables
    
    if (is.ordered(var)) {
        return(factor(var, levels = levels(var), ordered = TRUE))
    }
    
     var_factor <- factor(var) # Ensure it's a factor first
     num_levels <- nlevels(var_factor)

    if(var_name == "Country") {
      country_counts <- sort(table(var_factor), decreasing = TRUE)
       # Select top N bins, or fewer if not enough countries exist
      top_n_actual <- min(n_bins, length(country_counts))
      top_countries <- names(country_counts)[1:top_n_actual]

      if (!show_other_opt && length(country_counts) > top_n_actual) {
         # If 'Other' is hidden and there are more countries than bins,
         # Keep only top N, set others to NA (will be dropped later)
          var_factor <- factor(ifelse(var %in% top_countries, as.character(var), NA), levels=top_countries)
      } else if (show_other_opt && length(country_counts) > top_n_actual) {
         # If 'Other' is shown and there are more countries than bins, group remaining into 'Other'
          var_factor <- factor(ifelse(var %in% top_countries, as.character(var), "Other"), levels=c(top_countries, "Other"))
      } else {
         # If fewer countries than bins, or 'Other' is hidden and exactly N countries, keep all as is
          var_factor <- factor(var, levels = names(country_counts)) # Use existing levels
      }
      return(var_factor)

    } else {
      # For other categorical variables
      if (num_levels > n_bins) {
        category_counts <- sort(table(var_factor), decreasing = TRUE)
        top_n_actual <- min(n_bins, length(category_counts))
        top_cats <- names(category_counts)[1:top_n_actual]
        # Group remaining into "Other" - assuming 'Other' is always acceptable for non-Country categoricals
        var_factor <- factor(ifelse(var %in% top_cats, as.character(var), "Other"), levels = c(top_cats, "Other"))
        return(var_factor)
      } else {
        # Fewer levels than bins, return as is
        return(var_factor)
      }
    }
  }
}


ui <- fluidPage(
  useShinyjs(),
  # Application title
  titlePanel("Alzheimer's Risk Factors Explorer"),

  # Sidebar with controls
  sidebarLayout(
    sidebarPanel(
      # Tab selection
      tabsetPanel(
        id = "sidebar_tabs",
        tabPanel("Correlation Explorer",
                 selectInput("xvar", "X Variable:", choices = NULL), 
                 selectInput("yvar", "Y Variable:", choices = NULL),
                 radioButtons("summary_metric", "Summary Metric:",
                              choices = c("Alzheimer's Percentage" = "alz_pct",
                                          "Average Age" = "avg_age",
                                          "Count" = "count"),
                              selected = "alz_pct"),
                 sliderInput("bin_count", "Number of Groups:",
                             min = 2, max = 20, value = 10), # Min changed to 2 for safety
                 checkboxInput("show_other", "Show 'Other' Category for Country", FALSE,
                               width = "100%")
        ),
        tabPanel("Filters",
                 sliderInput("age_range", "Age Range:",
                             min = 20, max = 100, value = c(20, 100)),
                 selectInput("gender", "Gender:",
                             c("All", "Male", "Female")),
                 selectInput("diagnosis", "Alzheimer's Diagnosis:",
                             c("All", "Yes", "No"))
        )
      ),

      # Action button for filtering
      actionButton("apply_filters", "Apply Filters",
                   class = "btn-primary",
                   style = "margin-top: 10px; width: 100%")
    ),

    # Main panel with visualization outputs
    mainPanel(
      tabsetPanel(
        tabPanel("Visualizations",
                 plotlyOutput("main_plot", height = "500px"),
                 htmlOutput("plot_explanation"))
      )
    )
  )
)

# Server logic
server <- function(input, output, session) {
  
  ordered_factor_definitions <- list(
    # Group 1: Standard Low/Medium/High
    list(
      cols = c("Social Engagement Level", "Income Level", "Depression Level", "Air Pollution Exposure", "Stress Level", "Cholesterol Level", "Physical Activity Level"),
      levels = c("Low", "Medium", "High")
    ),
    list(
      cols = c("Sleep Quality"),
      levels = c("Poor", "Average", "Good")
    ),
    list(
      cols = c("Alcohol Consumption"),
      levels = c("Never", "Occasionally", "Regularly")
    ),
    list(
      cols = c("Smoking Status"),
      levels = c("Never", "Former", "Current")
    )
  )

  # Read the data - reactive expression for the raw data
  raw_data <- reactive({
       df = read_csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv",
                show_col_types = FALSE) 
      for (def in ordered_factor_definitions) {
            # Find which columns from the current definition actually exist in the data
            cols_to_process <- intersect(def$cols, names(df))
  
            # Only proceed if any columns matched
            if (length(cols_to_process) > 0) {
                # Apply the factor conversion using the defined levels
                df <- df %>%
                    mutate(across(all_of(cols_to_process),
                                  ~factor(., levels = def$levels, ordered = TRUE)))
            } else {
                warning(paste("Defined ordered columns not found in data:", paste(def$cols, collapse=", ")))
            }
        }
      df
  })

  # Update the correlation dropdowns with actual column names when data is loaded
  observe({
      req(raw_data()) # Ensure raw_data is loaded
      # Filter out potentially problematic columns if needed, e.g., ID columns
      # cols <- names(raw_data())[sapply(raw_data(), function(x) !is.character(x) || length(unique(x)) > 1)]
      cols <- names(raw_data())
      # Set initial selections more robustly
      selected_x <- if ("Age" %in% cols) "Age" else cols[1]
      selected_y <- if ("Cognitive Test Score" %in% cols) "Cognitive Test Score" else cols[min(2, length(cols))]

      updateSelectInput(session, "xvar", choices = cols, selected = selected_x)
      updateSelectInput(session, "yvar", choices = cols, selected = selected_y)
  })

  # Update the slider range for age based on the actual data
   observe({
       req(raw_data())
       min_age <- floor(min(raw_data()$Age, na.rm = TRUE))
       max_age <- ceiling(max(raw_data()$Age, na.rm = TRUE))
       updateSliderInput(session, "age_range", min = min_age, max = max_age, value = c(min_age, max_age))
   })


  # Toggle and update the 'show_other' checkbox based on variable selection
  observe({
    req(input$xvar, input$yvar) # Ensure inputs are available
    needs_other_option <- input$xvar == "Country" || input$yvar == "Country"
    shinyjs::toggleState(id = "show_other", condition = needs_other_option)

    # Update the checkbox label
    label_text <- "Show 'Other' Category for Country"
    if (needs_other_option) {
        if (input$xvar == "Country" && input$yvar != "Country") {
            label_text <- "Show 'Other' Category for Country (X-axis)"
        } else if (input$xvar != "Country" && input$yvar == "Country") {
            label_text <- "Show 'Other' Category for Country (Y-axis)"
        } else if (input$xvar == "Country" && input$yvar == "Country") {
             label_text <- "Show 'Other' Category for Countries"
        }
    }
    updateCheckboxInput(session, "show_other", label = label_text)

     # If neither is country, reset checkbox to FALSE and disable it
     if (!needs_other_option) {
       updateCheckboxInput(session, "show_other", value = FALSE)
     }
  })

  # Apply filters to the data - triggered by button
  # This performs the main data reduction based on user filters
  filtered_data <- eventReactive(input$apply_filters, {
    req(raw_data(), input$age_range, input$gender, input$diagnosis) # Ensure dependencies are met
    df <- raw_data()

    # Apply age filter
    df <- df %>% filter(Age >= input$age_range[1] & Age <= input$age_range[2])

    # Apply gender filter if not "All"
    if(input$gender != "All") {
      df <- df %>% filter(Gender == input$gender)
    }

    # Apply diagnosis filter if not "All"
    # Use the correct column name `Alzheimer’s Diagnosis`
    if(input$diagnosis != "All") {
      df <- df %>% filter(`Alzheimer’s Diagnosis` == input$diagnosis)
    }

    df
  }, ignoreNULL = FALSE) # ignoreNULL = FALSE ensures it runs on startup with initial values


  aggregated_data <- reactive({
      req(filtered_data(), input$xvar, input$yvar, input$bin_count, input$summary_metric)
      # Ensure selected variables exist in the filtered data
      validate(
          need(input$xvar %in% names(filtered_data()), paste("X Variable:", input$xvar, "not found.")),
          need(input$yvar %in% names(filtered_data()), paste("Y Variable:", input$yvar, "not found."))
      )

      df <- filtered_data()
      x_var_name <- input$xvar
      y_var_name <- input$yvar

       # Check if data is empty after filtering
       validate(need(nrow(df) > 0, "No data available for the selected filters."))

      # Create bins for x and y variables using the helper function
      # Need to handle potential errors if binning fails (e.g., all NAs)
       x_bins <- tryCatch({
           create_bins(df[[x_var_name]], x_var_name, input$bin_count, input$show_other)
       }, error = function(e) {
           showNotification(paste("Error creating bins for X variable:", e$message), type = "error")
           return(NULL)
       })
       validate(need(!is.null(x_bins), "Failed to create bins for X variable."))

       y_bins <- tryCatch({
           create_bins(df[[y_var_name]], y_var_name, input$bin_count, input$show_other)
       }, error = function(e) {
           showNotification(paste("Error creating bins for Y variable:", e$message), type = "error")
           return(NULL)
       })
       validate(need(!is.null(y_bins), "Failed to create bins for Y variable."))


      # Create a data frame with the binned variables
      binned_df <- df %>%
        mutate(
          x_binned = x_bins,
          y_binned = y_bins
        ) %>%
        # Drop rows where binning resulted in NA (e.g. 'Other' country when hidden)
        # or original value was NA
        drop_na(x_binned, y_binned)

       # Check if data is empty after binning and dropping NAs
       validate(need(nrow(binned_df) > 0, "No data points remaining after grouping/binning."))

       
      # Summarize the data based on the bins
      summary_df <- binned_df %>%
        group_by(x_binned, y_binned, .drop = FALSE) %>% # .drop=FALSE keeps all factor levels
        summarise(
          count = n(),
           # Ensure 'Alzheimer’s Diagnosis' column exists before summarising
           alz_count = if ("Alzheimer’s Diagnosis" %in% names(.)) sum(`Alzheimer’s Diagnosis` == "Yes", na.rm = TRUE) else 0,
           alz_pct = if ("Alzheimer’s Diagnosis" %in% names(.)) mean(`Alzheimer’s Diagnosis` == "Yes", na.rm = TRUE) * 100 else 0,
           avg_age = if ("Age" %in% names(.)) mean(Age, na.rm = TRUE) else NA_real_,
           .groups = "drop" # Drop grouping structure after summarising
        ) %>%
         filter(count > 0) # Remove combinations with zero counts if .drop=FALSE kept them

       # Check if summary resulted in data
        validate(need(nrow(summary_df) > 0, "Aggregation resulted in empty dataset. Check binning and filters."))
      # print(summary_df)
      return(summary_df)
  })


  # Render the main plot using the pre-aggregated data
  output$main_plot <- renderPlotly({
    summary_df <- aggregated_data() # Use the aggregated data

    # Determine title and color scale based on selected summary metric
    color_var <- input$summary_metric
    fill_label <- ""
    color_scale <- NULL # Initialize

    if(color_var == "alz_pct") {
      title <- paste("Alzheimer's Percentage by", input$xvar, "and", input$yvar)
      fill_label <- "Alzheimer's %"
      color_scale <- scale_fill_gradient(low = "#00b300", high = "#e10000", name = fill_label, na.value="grey80")
      hover_text <- with(summary_df,
                         paste0(input$xvar, ": ", x_binned, "<br>",
                                input$yvar, ": ", y_binned, "<br>",
                                "Alzheimer's: ", round(alz_pct, 1), "%",
                                "<br>Count: ", count,
                                "<br>Average Age: ", round(avg_age, 1)))
    } else if(color_var == "avg_age") {
      title <- paste("Average Age by", input$xvar, "and", input$yvar)
      fill_label <- "Average Age"
      color_scale <- scale_fill_viridis_c(option = "viridis", name = fill_label, na.value="grey80")
       hover_text <- with(summary_df,
                         paste0(input$xvar, ": ", x_binned, "<br>",
                                input$yvar, ": ", y_binned, "<br>",
                                "Average Age: ", round(avg_age, 1),
                                "<br>Alzheimer's: ", round(alz_pct, 1), "%",
                                "<br>Count: ", count))
    } else { # count
      title <- paste("Number of People by", input$xvar, "and", input$yvar)
      fill_label <- "Count (log10)"
       # Handle potential log(0) issues for color scale if counts are 0 (though filtered above)
       # Use sqrt transform for better visual spread if log is problematic
      color_scale <- scale_fill_viridis_c(option = "plasma", name = fill_label, na.value="grey80", trans = "sqrt") # Using sqrt instead of log10 for robustness
      hover_text <- with(summary_df,
                         paste0(input$xvar, ": ", x_binned, "<br>",
                                input$yvar, ": ", y_binned, "<br>",
                                "Count: ", count,
                                "<br>Alzheimer's: ", round(alz_pct, 1), "%",
                                "<br>Average Age: ", round(avg_age, 1)))
    }

    # Size of points based on count (sqrt scale for better visual scaling)
    # Add small constant to avoid sqrt(0) issues if counts can be 0
    

    # Create the plot with ggplot2
    p <- ggplot(summary_df, aes(
      x = x_binned,
      y = y_binned,
      fill = .data[[color_var]], # Use .data pronoun for programmatic variable names
      size = 5,
      text = hover_text # Map hover text to the 'text' aesthetic for ggplotly
    )) +
      geom_point(shape = 21, alpha = 0.8, na.rm = TRUE) + # Use shape 21 for fillable points
      labs(title = title,
           x = input$xvar,
           y = input$yvar) +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1, size=9), # Adjust text size if needed
        axis.text.y = element_text(size=9), # Adjust text size if needed
        legend.position = "right",
        plot.title = element_text(hjust = 0.5) # Center title
      ) +
      color_scale + # Apply the determined color scale
      scale_size(range = c(2, 10)) + # Control min/max size of points
      guides(size = "none") # Hide the size legend

    # Convert to plotly with custom hover
    # Need to ensure x/y axes are treated as categorical if they are factors/character
     # This often happens automatically, but can force with layout(xaxis=list(type="category")) if needed
    ggplotly(p, tooltip = "text") %>%
      layout(margin = list(b = 100, l = 100)) # Adjust margins as needed

  })


  # Update the explanation for the plot based on the summary metric
  output$plot_explanation <- renderUI({
    req(input$summary_metric)
    explanation_text <- switch(input$summary_metric,
                               "alz_pct" = "the percentage with Alzheimer's in that group.",
                               "avg_age" = "the average age of people in that group.",
                               "count"   = "how many people are in that group (log scale).",
                               "an unknown metric.") # Default case

    tags$div(style="margin-top: 15px;",
      tags$h4("What does this chart show?"),
      tags$p(paste("This chart groups people based on the selected X variable (", input$xvar, ") and Y variable (", input$yvar,"). Each variable is divided into approximately", input$bin_count, "groups (bins).")),
      tags$p("Each bubble represents one combination of an X-group and a Y-group."),
      tags$p("The color shows", explanation_text),
      tags$p("Hover over bubbles to see detailed information for that specific group combination."),
       if(input$xvar == "Country" || input$yvar == "Country") {
          tags$p(paste("For Country:", if(input$show_other) "Less frequent countries are grouped into 'Other'." else "Only the most frequent countries are shown."))
       }
    )
  })

}

# Run the application
shinyApp(ui = ui, server = server)
```

---

## Jack Original Code

```{r}
library(shiny)
library(ggplot2)
library(reshape2)
library(dplyr)

alzheimers <- read.csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv")

country_choices <- c("All Countries", sort(unique(alzheimers$Country)))

ui <- fluidPage(
  titlePanel("Alzheimer's Disease Heatmap by Gender and Selected Health Conditions"),
  sidebarLayout(
    sidebarPanel(
      selectInput("country", "Select Country:", 
                  choices = country_choices,
                  selected = "All Countries")
      ),
    
    mainPanel(
      plotOutput("heatmap"),
      br(),
      textOutput("summary"),
      br(),
      tableOutput("data_table")
    )
  )
)

server <- function(input, output) {
  filtered_data <- reactive({
    if(input$country == "All Countries") {
      data <- alzheimers
    } else {
      data <- alzheimers %>% filter(Country == input$country)
    }
    return(data)
  })
  
  heatmap_data <- reactive({
    alzheimer_cases <- filtered_data() %>% 
      filter(Alzheimer.s.Diagnosis == "Yes")
    if(nrow(alzheimer_cases) == 0) {
      return(NULL)
    }

    diabetes_gender <- table(alzheimer_cases$Gender, alzheimer_cases$Diabetes)
    diabetes_melted <- melt(diabetes_gender)
    colnames(diabetes_melted) <- c("Gender", "Condition", "Count")
    diabetes_melted$HealthFactor <- "Diabetes"
    
    hypertension_gender <- table(alzheimer_cases$Gender, alzheimer_cases$Hypertension)
    hypertension_melted <- melt(hypertension_gender)
    colnames(hypertension_melted) <- c("Gender", "Condition", "Count")
    hypertension_melted$HealthFactor <- "Hypertension"
    
    stress_gender <- table(alzheimer_cases$Gender, alzheimer_cases$Stress.Levels)
    stress_melted <- melt(stress_gender)
    colnames(stress_melted) <- c("Gender", "Condition", "Count")
    stress_melted$HealthFactor <- "Stress.Levels"
    
    heatmap_data <- rbind(diabetes_melted, hypertension_melted, stress_melted)
    
    heatmap_data$HealthFactor <- factor(heatmap_data$HealthFactor, 
                                      levels = c("Diabetes", "Hypertension", "Stress.Levels"))
    
    return(heatmap_data)
  })
  
  output$heatmap <- renderPlot({
    data <- heatmap_data()
    if(is.null(data) || nrow(data) == 0) {
      ggplot() + 
        annotate("text", x = 0.5, y = 0.5, label = "No Alzheimer's cases found for the selected country") +
        theme_void() +
        xlim(0, 1) + 
        ylim(0, 1)
    } else {
      ggplot(data, aes(x = Gender, y = paste(HealthFactor, "-", Condition), fill = Count)) +
        geom_tile(color = "white") +
        geom_text(aes(label = Count), color = ifelse(data$Count > max(data$Count)/2, "white", "black"), size = 4) +
        scale_fill_gradient(low = "white", high = "steelblue", 
                            name = "Alzheimer's\nCases") +
        labs(title = paste("Alzheimer's Cases by Gender and Health Conditions", 
                           if(input$country != "All Countries") paste("in", input$country) else ""),
             x = "Gender", 
             y = "") +
        theme_minimal() +
        theme(axis.text.y = element_text(size = 10),
              plot.title = element_text(hjust = 0.5, face = "bold"))
    }
  })
  
  output$summary <- renderText({
    alzheimer_count <- sum(filtered_data()$Alzheimer.s.Diagnosis == "Yes")
    total_count <- nrow(filtered_data())
    
    paste("Summary: There are", alzheimer_count, "Alzheimer's cases out of", 
          total_count, "surveyed individuals", 
          if(input$country != "All Countries") paste("in", input$country) else "across all countries", 
          "(", round(alzheimer_count/total_count*100, 1), "%).")
  })
  
  output$data_table <- renderTable({
    if(input$country == "All Countries") {
      alzheimers %>% 
        group_by(Country) %>%
        summarize(
          Total = n(),
          `Alzheimer's Cases` = sum(Alzheimer.s.Diagnosis == "Yes"),
          `Percentage (%)` = round(sum(Alzheimer.s.Diagnosis == "Yes") / n() * 100, 1)
        ) %>%
        arrange(desc(`Alzheimer's Cases`))
    } else {
      ad_cases <- filtered_data() %>% filter(Alzheimer.s.Diagnosis == "Yes")
      if(nrow(ad_cases) == 0) {
        data.frame(Message = paste("No Alzheimer's cases found in", input$country))
      } else {
        ad_cases %>%
          select(Gender, Diabetes, Hypertension, Stress.Levels)
      }
    }
  })
}

shinyApp(ui = ui, server = server)
```

---

## Beomseong Original Code

```{r}
library(shiny)
library(dplyr)
library(plotly)
library(readr)

alz = read_csv("https://uwmadison.box.com/shared/static/a2a74zejbdt5ywk7pxsvsw06gsypi8to.csv")
```

```{r}
ui = fluidPage(
  titlePanel("Comparative Distribution Analysis of Alzheimer’s Factors"),
  sidebarLayout(
    sidebarPanel(
    sliderInput(inputId = "ageRange", label = "Age Range:", 
                min = floor(min(alz$Age, na.rm = TRUE)), 
                max = ceiling(max(alz$Age, na.rm = TRUE)), 
                value = c(50, 90)),
      selectInput(inputId  = "genderFilter",
                  label = "Gender:",
                  choices = c("All", unique(alz$Gender)),
                  selected = "All"),
      selectInput(inputId  = "countryFilter",
                  label = "Country:",
                  choices  = c("All", unique(alz$Country)),
                  selected = "All"),
      selectInput(inputId = "varChoice",
                  label = "Variable to Analyze:",
                  choices = c("Physical Activity Level",
                              "Smoking Status",
                              "Alcohol Consumption",
                              "Diabetes",
                              "Hypertension",
                              "Cholesterol Level",
                              "Family History of Alzheimer’s",
                              "Genetic Risk Factor (APOE-ε4 allele)",
                              "Stress Levels"),
        selected = "Physical Activity Level")),
    mainPanel(tabsetPanel(
      tabPanel("Alzheimer's Diagnosis Overview",
               plotlyOutput("pieDiagnosisPlot"))))))
```

```{r}
server = function(input, output, session) {
  # Return filtered data based on age, gender, and country filters
  filtered_data = reactive({
    df = alz
    df = df %>%
      filter(Age >= input$ageRange[1], Age <= input$ageRange[2])
    if (input$genderFilter != "All") {
      df = df %>% filter(Gender == input$genderFilter)} 
    if (input$countryFilter != "All") {
      df = df %>% filter(Country == input$countryFilter)}
    return(df)})
  
  # Render side-by-side pie charts for AD diagnosis (Yes and No)
  output$pieDiagnosisPlot = renderPlotly({
    var = input$varChoice
    df_filtered = filtered_data()
    
    # AD = Yes
    df_yes = df_filtered %>%
      filter(`Alzheimer’s Diagnosis` == "Yes") %>%
      group_by(.data[[var]]) %>%
      summarize(count = n(), .groups = "drop") %>%
      filter(!is.na(.data[[var]]))
    
    # AD = No
    df_no = df_filtered %>%
      filter(`Alzheimer’s Diagnosis` == "No") %>%
      group_by(.data[[var]]) %>%
      summarize(count = n(), .groups = "drop") %>%
      filter(!is.na(.data[[var]]))
    
    plot_ly() %>%
      add_pie(data = df_yes, labels = ~.data[[var]], values = ~count,
              name = "AD = Yes", domain = list(x = c(0, 0.45), y = c(0, 1))) %>%
      add_pie(data = df_no, labels = ~.data[[var]], values = ~count,
              name = "AD = No", domain = list(x = c(0.55, 1), y = c(0, 1))) %>%
      layout(title = paste("AD Diagnosis Pie Charts by", var), showlegend = TRUE, 
             legend = list(orientation = "h"), template = "plotly_dark")
  })
}

shinyApp(ui, server)
```



